%
% 	Creating Test Models
%
\label{sec:create-test-model}
The framework relies on a set of primary and subsidiary models that have to be  created or generated by testers and provided to the framework. These models are automatically translated into Alloy models which are the actual models used for the test generation and execution. This section describes how the required models are created or generated in the context of the example library system. %It also covers some implementation aspects.?

\subsection{Structural Model}
\label{sec:create-test model-structure}
The structural model is created based on the EMF model of the SUT that only shows the structure of the class diagram; it does not include the internal data of the classes. The class diagram and the EMF model of the example library system is depicted in Fig.~\ref{fig:library-structure-model}.

\begin{figure}[h]
\centering
\subfloat[EMF Model]{\includegraphics[width=0.4\textwidth]{../Figures/library-class-diagram}%
\label{fig:library-emf}}
\hfil
\subfloat[Class Diagram]{\includegraphics[width=0.3\textwidth]{../Figures/library-emf}%
\label{fig:library-class}}
\caption{Structural model of the example library system.}
\label{fig:library-structure-model}
\end{figure} 

Using the Eclipse\footnote{Eclipse - \url{http://eclipse.org}} IDE, the Java code of the EMF model is generated. This code is required and used in defining the behavioural model. The EMF model is also transformed into an Alloy specification (.als file), which is the actual structural model used in the testing process. The detail of model transformations into Alloy are provided in Section~\ref{sec:alloy-structure}.

\subsection{Behavioural Model}
\label{sec:create-test model-behaviour}
The first step in defining the behavioural model is to identify object labels, as labels are used in creating the behavioural model (defining use cases). The labels can be identified by considering the state-based behaviour of the system, implied by use cases. For example, in the library system, the class \texttt{Book} has two labels: \textit{Borrowed} and \textit{NotBorrowed}, and the class \texttt{Member} has three labels: \textit{HasNotBorrowed}, \textit{CanBorrow}, and \textit{CanNotBorrow}. Fig.~\ref{fig:library-object-labels} shows the labels and illustrates how they relate to use cases.

\begin{figure}[h]
\centering
\subfloat[Member]{\includegraphics[width=0.4\textwidth]{../Figures/member-labels}%
\label{fig:library-member-labels}}
\hfil
\subfloat[Book]{\includegraphics[width=0.3\textwidth]{../Figures/book-labels}%
\label{fig:library-book-labels}}
\caption{State diagram showing the object labels in the library system.}
\label{fig:library-object-labels}
\end{figure} 

After defining the object labels, the behavioural model is created which consists of description of use cases with the introduced DSL. Fig.~\ref{fig:library-usecase-borrow-book} shows the description of ``Borrow Book" use case using the DSL. 

\begin{figure*}[h]
\centering
\includegraphics[width=0.7\textwidth]{../Figures/borrow-book.png}
\caption{The behavioural modelling for ``Borrow Book" use case using our DSL.}
\label{fig:library-usecase-borrow-book}
\end{figure*}

Each use case is defined with a Java class which is annotated as \texttt{@SystemOperation}, which is used by the framework to identify the system use cases. A use case description specifies one or more execution paths that are defined as a method using the signature shown in line 3 in Fig.~\ref{fig:library-usecase-borrow-book}. These methods are annotated as \texttt{@Description} and return an object of type \texttt{ModelExpectations}. 

The core of the behavioural modelling is performed in the configuration of this object (line 5 to 12). Firstly (lines 5-7), the parameters and the pre-conditions of the use case are defined and introduced to the framework. Line 5 shows that there is a parameter of type \texttt{BOOK} called \texttt{thisBook}, in the use case (the words in capital letters refer to the domain model Java code generated by EMF). The \textit{inState} method specifies the permissible labels for an object. Line 5 of Fig.~\ref{fig:library-usecase-borrow-book} indicates that the book to borrow has not been already borrowed; its label should be \texttt{Not Borrowed}. Similarly, line 6 and 7 describe the parameter of type \texttt{Member} and its permissible labels.
In the second part (line 9 to 12), the post-conditions of the execution path of the used case are described, such as changing the state to a specific state (line 9) or an arbitrary state (line 10), and adding a relation to the specified relation type (line 11). 
%Table~\ref{tbl:behavioural-modelling-preconditions} and Table~\ref{tbl:behavioural-modelling-postconditions}, in Appendix~\ref{app:behavioural-modelling}, list all the modelling features provided in the framework.

\subsection{Test Data}
\label{sec:create-test model-data}
One of the main, and challenging, tasks in testing is test data generation. This sections describes how data is generated for use cases that needs input data. As mentioned before in Section~\ref{sec:framework-overview-test-data}, we use the input partitioning approach for data generation.The partitioning of input parameters are defined by the tester, based on the system requirements, and introduced to the framework. For example, the ``Add Book" use case requires the input parameter \textit{bookName} that should be automatically generated. A book name is a string and is partitioned into ``empty", ``duplicate", and ``unique".

For defining the partitioning of a data type, the data type has to be defined and introduced to the framework. A data type is an implementation of the \texttt{DataFactory} interface in which each partition is represented by a method annotated as \texttt{@Partition} and returns an object of type \texttt{PartitionDescription}. Each \texttt{PartitionDescription} is responsible for data generation for its own partition, in its \texttt{generate} method. Fig.~\ref{fig:library-bookname} shows the definition of \texttt{BookName} data type and its partitioning namely ``empty", ``unique", and ``nonUnique". In lines 31-41, the partitioning is defined. Each partition extends  \texttt{PartitionDescription} and implements the \texttt{generate} method that is the main method for generating data for that partition. For example, lines 2-6 introduce the ``empty" partition that returns an \textit{empty} string in its \texttt{generate} method.

\begin{figure}[h]
\centering
{\includegraphics[width=0.5\textwidth]{../Figures/bookname-1}%
\label{fig:library-bookname-1}}
\hfil
{\includegraphics[width=0.5\textwidth]{../Figures/bookname-2}%
\label{fig:library-bookname-2}}
\caption{Defining \texttt{BookName} data type and its partitioning.}
\label{fig:library-bookname}
\end{figure} 

If the data generation requires access to the domain objects, this dependency is specified in the \texttt{getDataParams} method that returns a list of required objects. This list is then passed to the \texttt{generate} method, in addition to the \texttt{SoftwareSystem} object. The data generation for the ``nonUnique" partition, in Fig.~\ref{fig:library-bookname}, requires a book name that already exists in the system. This is done in lines 18-21 and the returned object that is used in the \texttt{generate} method, lines 24-28, as the generated (non-unique) book name. Fig.~\ref{fig:library-usecase-add-book} shows how a data type and its partitioning are used in modelling a use case. In line 4, calling the method \texttt{input} and referring to the \texttt{BookName} data type define a parameter for the use case. The method \texttt{inPartition} restricts the permissible partitions for that parameter.

\begin{figure*}[h]
\centering
\includegraphics[width=0.7\textwidth]{../Figures/add-book.png}
\caption{Using the data types and their partitioning in use case modelling.}
\label{fig:library-usecase-add-book}
\end{figure*}

\subsection{Test Harness}
\label{sec:create-test model-test-harness}
The test harness, an SUT-specific code developed by the tester, is responsible for the communications between the test driver and the SUT, including executing use cases, observing the internal state of the SUT, which are performed by ``Command Executor" and ``Inspector" components respectively.
The test harness also includes the data generator that generates appropriate test data for use cases. The generator is developed in the context of the ``Command Executor".

\subsubsection{Introducing the SUT}
\label{sec:test-harness-intro-SUT}
In order to introduce an SUT to the framework, the \texttt{SoftwareSystem} interface is defined and provided to testers. The test harness introduces an object that implements this interface to the testing framework as the system under test. Later on, this object is used for executing commands and inspection; it is passed to these components. The \texttt{SoftwareSystem} interface has a \texttt{reset} method which is for bringing the system into its initial state. This interface and its implementation for the example library system is shown in Fig.~\ref{fig:library-SUT}.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{../Figures/library-SUT.png}
\caption{The \texttt{SoftwareSystem} interface and its implementation for example library system.}
\label{fig:library-SUT}
\end{figure}


\subsubsection{Inspection}
\label{sec:test-harness-inspection}
The test harness has to be able to return a list of the objects, with their associated labels, for each class in the domain model. Each object is introduced with a unique identifier (ID) to the testing framework. The identifiers are managed by the test harness and the SUT. Accordingly, an abstract super class (\texttt{AbstractDomainObjInspector})  is provided that is inherited by the test harness. Fig.~\ref{fig:library-inspector} shows an example implementation of this super class and the inspector for the \texttt{Member} class.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{../Figures/library-inspector.png}
\caption{An example inspector, for the ``Member" class.}
\label{fig:library-inspector}
\end{figure}

The \texttt{@Inspector} annotation with the name of the target \texttt{type}, in line 1, allows the framework to identify the inspector for the target domain class (e.g., ``Member" in Fig.~\ref{fig:library-inspector}) . The constructor, line 5-7, takes an object implementing \texttt{SoftwareSystem}, which is the object representing the SUT (mentioned in Section~\ref{sec:test-harness-intro-SUT}). The \texttt{getObjectState} returns the labels of the object with the input ID, and the \texttt{getObjectList} returns the IDs of all the objects of the target type. The body of these two methods are implemented for the SUT.

\subsubsection{Command Execution}
\label{sec:test-harness-command-execution}
The test harness implements the \texttt{Command} interface (Fig.~\ref{fig:test-harness-command-interface}) for each use case so that the use case is related to the SUT and it is possible to run the test cases on the SUT. Each use case description class should have a \texttt{execute} method that returns an object of type \texttt{Command}. Calling this method would not execute the use case, it just creates a \texttt{Command} object which, later on, is used for test case execution by the framework during the test execution process.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{../Figures/command-interface.png}
\caption{\texttt{Command} interface.}
\label{fig:test-harness-command-interface}
\end{figure}

An implementation of the \texttt{command} method, for the ``Borrow Book" use case, has been shown in Fig.~\ref{fig:library-borrow-book-execute}, line 7-20. Considering the use case description in Fig.~\ref{fig:library-usecase-borrow-book}, the use case has two parameters which are passed to the \texttt{execute} method as objects of type \texttt{DomainParam}. These objects have a method, called \texttt{lookup}, which returns the ID of the object. The IDs are required in use case execution.

\begin{figure*}[h]
\centering
\includegraphics[width=0.7\textwidth]{../Figures/borrow-book-execute.png}
\caption{Implementation of the \texttt{Command} interface for ``Borrow Book" use case.}
\label{fig:library-borrow-book-execute}
\end{figure*}

Additionally, Fig.~\ref{fig:library-usecase-add-book} shows how a data type is used in defining the implementation of the \texttt{execute} method (or creating the \texttt{command} object) for the ``Add Book" use case which requires an input parameter.  In line 8, the input parameter is passed to the \texttt{execute} method, as an object of type \texttt{InputParam} which has a \texttt{generate} method (line 12). Calling this method will call the \texttt{generate} method of the related partition and hence, results in generating appropriate test data. 

\subsection{Subsidiary Models}
\label{sec:create-test model-subsidiary-models}
The testing framework also relies on three subsidiary models that are smaller and less important than other models, namely the initial state, object labels rules, and test goals. There are two built-in test goals including 1) successful execution of use cases, and 2) running the system aiming at falsifying the pre-conditions of a use case. The (user defined) test goals are specified in the Alloy models and thus the test goals are not discussed (covered) in this section.

\subsubsection{Initial State}
\label{sec:subsidiary-models-initial-state}
This model specifies the objects in the initial state, with their labels and the relations between them. Fig.~\ref{fig:library-initial-state} specifies an initial state for the example library system. The initial state model consists of one book and one member that has borrowed the book.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{../Figures/library-initial-state.png}
\caption{An initial state model for the library system.}
\label{fig:library-initial-state}
\end{figure}

\subsubsection{Object Labels Rules}
\label{sec:subsidiary-models-object-labels}
As mentioned before, certain constraints on relations between objects (e.g., number of involved objects in a relation) can not be specified in the behavioural model. For example, in the modelling of the post-conditions of  the``Borrow Book" use case (Fig.~\ref{fig:library-usecase-borrow-book}), the label of the object \texttt{thisMember} can not be determined as it is dependant on its label before the execution of the use case. 
Such dependencies are defined in the models describing the rules applied on the objects to determine their labels. Fig.~\ref{fig:library-rules-member} illustrates the rules applied on the ``Member" class and its labels. In line 3, the \texttt{setFor} method specifies the rules are applied for which class. Line 4 indicates that if the given relation (\texttt{MEMBER\_BORROW}) is empty then the label is \texttt{HasNotBorrowed}. Similarly, line 5 says if the size of the given relation (\texttt{MEMBER\_BORROW}) is equal or greater than two then the label is \texttt{CanNotBorrowed}. Line 6 indicates that the label would be \texttt{CanBorrow} if none of the other cases are applicable.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{../Figures/library-rules-member.png}
\caption{Modelling of rules applied in ``Member Class".}
\label{fig:library-rules-member}
\end{figure}

\subsection{Introducing the Models to the Framework}
\label{sec:create-test model-introducing-models}
All of the aforementioned models have to be introduced to the testing framework. To do so, each type of models are bundled into a package which are introduced to the framework by implementing the \texttt{SUT} interface. The implementation of the SUT is also introduced to the framework.Doing so, the testing process can be carried out.
The testing framework uses `reflection' to find the required classes (and methods) to execute the test cases (i.e.,\ corresponding use cases) on the system. The \texttt{SUT} interface is depicted in Fig.~\ref{fig:SUT-interface}. 

\begin{figure}[h]
\centering
\includegraphics[width=0.4\textwidth]{../Figures/SUT-interface.png}
\caption{\texttt{SUT} interface.}
\label{fig:SUT-interface}
\end{figure}
